<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <title>Интерактивное веб-приложение</title>
  <style>
    body, html {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: #333;
      color: #fff;
      font-family: Arial, sans-serif;
    }
    #videoContainer {
      position: relative;
    }
    video, canvas {
      position: absolute;
      top: 0;
      left: 0;
    }
    #controls {
      position: absolute;
      bottom: 10px;
      left: 10px;
      z-index: 10;
    }
    button {
      margin-right: 10px;
      padding: 10px;
      font-size: 14px;
    }
  </style>
</head>
<body>
  <div id="videoContainer">
    <!-- Видео с зеркальным эффектом -->
    <video id="video" autoplay playsinline style="transform: scaleX(-1);"></video>
    <!-- Холст для отрисовки рамок и линий -->
    <canvas id="overlay"></canvas>
  </div>
  <div id="controls">
    <button id="fullscreenBtn">Полный экран</button>
    <button id="switchCamBtn">Переключить камеру</button>
  </div>

  <!-- Подключаем Mediapipe Hands -->
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
  <!-- Подключаем face‑api.js -->
  <script defer src="https://cdn.jsdelivr.net/npm/face-api.js"></script>
  <!-- Подключаем TensorFlow.js и модель COCO-SSD -->
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/coco-ssd"></script>

  <script>
    // Элементы страницы
    const video = document.getElementById('video');
    const overlay = document.getElementById('overlay');
    const ctx = overlay.getContext('2d');
    const fullscreenBtn = document.getElementById('fullscreenBtn');
    const switchCamBtn = document.getElementById('switchCamBtn');

    // Переменные для камеры и режима рисования
    let currentStream;
    let currentFacingMode = 'user'; // 'user' – передняя, 'environment' – задняя
    let drawingMode = false;
    let drawingPath = [];
    let fistCount = 0;
    let lastGesture = '';
    let gestureTimeout;

    // Списки опасных объектов и еды для COCO-SSD
    const dangerousObjects = ['knife', 'pistol', 'scissors'];
    const foodObjects = ['apple', 'banana', 'pizza', 'orange', 'sandwich'];

    // Запуск камеры с нужной facingMode
    async function startCamera() {
      if (currentStream) {
        currentStream.getTracks().forEach(track => track.stop());
      }
      const constraints = { video: { facingMode: currentFacingMode } };
      try {
        currentStream = await navigator.mediaDevices.getUserMedia(constraints);
        video.srcObject = currentStream;
        video.onloadedmetadata = () => {
          video.play();
          overlay.width = video.videoWidth;
          overlay.height = video.videoHeight;
          startProcessing();
        };
      } catch (err) {
        console.error('Ошибка доступа к камере:', err);
      }
    }

    // Обработчики кнопок
    fullscreenBtn.addEventListener('click', () => {
      if (document.fullscreenElement) {
        document.exitFullscreen();
      } else {
        document.documentElement.requestFullscreen();
      }
    });

    switchCamBtn.addEventListener('click', () => {
      currentFacingMode = (currentFacingMode === 'user') ? 'environment' : 'user';
      startCamera();
    });

    // Инициализация Mediapipe Hands
    const hands = new Hands({
      locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
    });
    hands.setOptions({
      maxNumHands: 1,
      modelComplexity: 1,
      minDetectionConfidence: 0.7,
      minTrackingConfidence: 0.5
    });
    hands.onResults(onHandsResults);

    // Основной цикл обработки
    async function startProcessing() {
      // Загрузка моделей face‑api.js (необходимо разместить модели в папке /models)
      await faceapi.nets.tinyFaceDetector.loadFromUri('/models');
      await faceapi.nets.ageGenderNet.loadFromUri('/models');
      await faceapi.nets.faceExpressionNet.loadFromUri('/models');

      // Загрузка модели COCO-SSD
      window.cocoModel = await cocoSsd.load();

      requestAnimationFrame(processFrame);
    }

    async function processFrame() {
      // Отрисовка текущего кадра видео на холсте
      ctx.drawImage(video, 0, 0, overlay.width, overlay.height);

      // Обработка рук с помощью Mediapipe Hands
      await hands.send({ image: video });

      // Распознавание лиц с помощью face‑api.js
      const detections = await faceapi
        .detectAllFaces(video, new faceapi.TinyFaceDetectorOptions())
        .withAgeAndGender()
        .withFaceExpressions();

      detections.forEach(detection => {
        const { x, y, width, height } = detection.detection.box;
        ctx.strokeStyle = 'yellow';
        ctx.lineWidth = 2;
        ctx.strokeRect(x, y, width, height);
        // Определяем доминирующую эмоцию
        let expressions = detection.expressions;
        let maxEmotion = Object.keys(expressions).reduce((a, b) => expressions[a] > expressions[b] ? a : b);
        ctx.fillStyle = 'yellow';
        ctx.font = '16px Arial';
        ctx.fillText(`Возраст: ${Math.round(detection.age)} ${maxEmotion}`, x, y - 10);
      });

      // Распознавание объектов с помощью COCO-SSD
      window.cocoModel.detect(video).then(predictions => {
        predictions.forEach(prediction => {
          const [x, y, width, height] = prediction.bbox;
          let label = prediction.class;
          let color = 'yellow';
          if (dangerousObjects.includes(label.toLowerCase())) {
            color = 'red';
            label = `опасный: ${label}`;
          } else if (foodObjects.includes(label.toLowerCase())) {
            color = 'green';
            label = `еда: ${label}`;
          }
          ctx.strokeStyle = color;
          ctx.lineWidth = 2;
          ctx.strokeRect(x, y, width, height);
          ctx.fillStyle = color;
          ctx.font = '16px Arial';
          ctx.fillText(label, x, y > 20 ? y - 5 : y + 15);
        });
      });

      // Если активирован режим рисования, отрисовываем линию
      if (drawingMode && drawingPath.length > 1) {
        ctx.strokeStyle = 'black';
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(drawingPath[0].x, drawingPath[0].y);
        for (let i = 1; i < drawingPath.length; i++) {
          ctx.lineTo(drawingPath[i].x, drawingPath[i].y);
        }
        ctx.stroke();
      }
      requestAnimationFrame(processFrame);
    }

    // Обработка результатов от Mediapipe Hands
    function onHandsResults(results) {
      if (!results.multiHandLandmarks || results.multiHandLandmarks.length === 0) {
        return;
      }
      const landmarks = results.multiHandLandmarks[0];

      // Вычисление ограничивающего прямоугольника руки
      let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
      landmarks.forEach(point => {
        minX = Math.min(minX, point.x * overlay.width);
        minY = Math.min(minY, point.y * overlay.height);
        maxX = Math.max(maxX, point.x * overlay.width);
        maxY = Math.max(maxY, point.y * overlay.height);
      });
      ctx.strokeStyle = 'green';
      ctx.lineWidth = 2;
      ctx.strokeRect(minX, minY, maxX - minX, maxY - minY);

      // Простейшая логика жестов:
      // Считаем «сжатие кулака», если расстояние от запястья (landmark 0) до кончика среднего пальца (landmark 12) мало.
      const wrist = landmarks[0];
      const middleTip = landmarks[12];
      const dx = (middleTip.x - wrist.x) * overlay.width;
      const dy = (middleTip.y - wrist.y) * overlay.height;
      const dist = Math.sqrt(dx * dx + dy * dy);
      if (dist < 40) { // Жест "кулак"
        if (lastGesture !== 'fist') {
          fistCount++;
          lastGesture = 'fist';
          clearTimeout(gestureTimeout);
          gestureTimeout = setTimeout(() => { lastGesture = ''; }, 1000);
        }
      } else {
        // Если указательный палец (landmark 8) отстоит от запястья – считаем, что он вытянут
        const indexTip = landmarks[8];
        const idxDx = (indexTip.x - wrist.x) * overlay.width;
        const idxDy = (indexTip.y - wrist.y) * overlay.height;
        const idxDist = Math.sqrt(idxDx * idxDx + idxDy * idxDy);
        if (idxDist > 60 && lastGesture !== 'index') {
          lastGesture = 'index';
          // Если ранее было два «кулака», активируем режим рисования
          if (fistCount >= 2) {
            drawingMode = true;
            drawingPath = [];
          }
          if (drawingMode) {
            drawingPath.push({ x: indexTip.x * overlay.width, y: indexTip.y * overlay.height });
          }
        }
      }
      // Обнаружение жеста "OK": расстояние между большим (landmark 4) и указательным (landmark 8) пальцами мало
      const thumbTip = landmarks[4];
      const okDx = (thumbTip.x - landmarks[8].x) * overlay.width;
      const okDy = (thumbTip.y - landmarks[8].y) * overlay.height;
      const okDist = Math.sqrt(okDx * okDx + okDy * okDy);
      if (okDist < 30) { // Жест "OK" – очищаем рисунок
        drawingMode = false;
        drawingPath = [];
        fistCount = 0;
      }
    }

    // Запуск приложения
    startCamera();
  </script>
</body>
</html>
